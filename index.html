<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<!-- <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,user-scalable=no"> -->
	<title>常用设计模式小结</title>
	<style>
		body{font-family: 'Consolas';}
		*{margin: 0;padding: 0;}
		h2{text-align: center;line-height: 60px;}
		a{text-decoration: none;}
		a:visited{color: green}
		a:hover{color: red;}
		#fixedBar{position: fixed;top: 0;right:0; width: 20%; background-color: #ECF0F1;height: 100%;}
		#fixedBar ul{padding-top: 40px;}
		#fixedBar ul li {width: 100%;font-size: 18px;float: left;list-style: none;text-indent: 20px;line-height: 30px;transition: text-indent .4s;}
		#fixedBar ul li:hover{text-indent: 30px;}

		#container{width: 80%;}
		#container ul{margin: 20px;}
		#container ul li{list-style: none;margin-bottom: 20px;}
		#container ul li *{margin-bottom: 3px;}
		#container h3{border-top: 20px solid #fff;background-color: #3498ff;color: #fff;text-indent: 20px;}

		pre{border: 1px solid #BDC3C7;background-color: #ddd;}
	</style>
</head>
<body>
<div id="fixedBar">
	<ul>
		<li><a href="#a">1、策略模式</a></li>
		<li><a href="#b">2、代理模式</a></li>
		<li><a href="#c">3、单例模式</a></li>
		<li><a href="#d">4、迭代器模式</a></li>
		<li><a href="#e">5、发布-订阅模式</a></li>
		<li><a href="#f">6、命令模式</a></li>
		<li><a href="#g">7、模版方法模式</a></li>
		<li><a href="#h">8、享元模式</a></li>
		<li><a href="#i">9、职责链模式</a></li>
		<li><a href="#j">10、中介者模式</a></li>
		<li><a href="#k">11、装饰者模式</a></li>
		<li><a href="#l">12、状态模式</a></li>
		<li><a href="#m">13、组合模式</a></li>
	</ul>
</div>

<div id="container">
	<h2>常用设计模式小结</h2>
	<ul>
		<li>前言：看<strong>曾探</strong>的《JavaScript设计模式与开发实践》所写的笔记和自己的一些理解，主要用于自己的复习。</li>
		<li>
			<h3>书中第一部分的一些要点</h3>
			<p>duck typing : 鸭子类型指导我们只关注对象的行为，而不关注对象本身。</p>
			<p>多态 : 同一操作作用域不同的对象上面，可以产生不同的解释和不同的执行结果。多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。多态的根本作用就是把过程化的条件分支语句转化为对象的多态性从而消除这些条件分支语句。</p>
			<p>设计模式的分类 : 创建型（封装创建对象的变化）、结构型（封装对象之间的组合关系）、行为型（封装对象的行为变化）。</p>
			<p>AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，可以保持业务逻辑模块的纯净和高内聚性，方便的复用功能性的模块。</p>
			<p>闭包</p>
			<p>柯里化</p>
			<p>大量数据的分解加载</p>
			<p>this、call、apply、bind</p>
		</li>
		<li>
			<h3 id="a">1、策略模式</h3>
			<p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
			<p>目的：将算法的使用和算法的实现分离开来。</p>
			<p>组成：第一部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程，第二部分是环境类Context，Context接受客户的请求，随后把请求委托给某一策略类。</p>
			<p>优点：利用组合、委托和多态等技术和思想，可有效避免多重条件选择语句；易于切换、理解和扩展；可复用性高；</p>
			<p><strong>示例：</strong></p>
			<a href="pages/策略模式实现缓动动画.html" target="black">策略模式实现缓动动画</a>
			<a href="pages/策略模式实现表单校验.html" target="black">策略模式实现表单校验</a>
			<pre>
//策略类
var Strategy = {
	a:function(){
		//...
	},
	b:function(){
		//...
	},
	c:function(){
		//...
	}
};
//环境类
function Context(s, c){
	//进行一些逻辑上的处理
	//把请求委托给策略类
	Strategy[s](c);
}
//执行一下
Context('a', 'aaa');
			</pre>
		</li>
		<li>
			<h3 id="b">2、代理模式</h3>
			<p>定义：为一个对象提供一个代用品或占位符，以便控制对他的访问。</p>
			<p>保护代理：如果执行某项操作将会消耗很多资源，那么将想要执行这项操作的请求通过保护代理进行提交，在代理中去掉不符合的请求。</p>
			<p>虚拟代理：虚拟代理把一些开销很大的对象，延迟到真正需要它的时候采取创建。</p>
			<p>缓存代理：利用闭包为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前的一致，则可以直接返回前面存储的运算结果。</p>
			<p>**编写业务代码的时候不需要预先去猜测是否需要使用代理模式，当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>
			<pre>
//使用代理实现图片预加载时用loading进行占位的功能
//从服务器获取到的图片数据通常就是一堆链接，因此做成下面这种形式更好用点，但是这样不能使代理和本体保持一直性，即无法相互替换
var createImg = (function(){
	var create = function(){
		var img = document.createElement('img');
		this.img = img;
	};
	create.prototype.setSrc = function(src){
		this.src = src;
	};
	return function(){
		return new create();
	};
})();
//经过考虑，这里不可以使用闭包只声明一个img
//如果用一个循环多次调用此函数，那么一个img的src会被不断覆盖，最后所有图片得到的都是同一张图片
var proxyImgLoading = function(setimage, src){
	var img = new Image();
	setimage.src = 'loading.gif';
	img.src = src;
	img.onload = function(){
		setimage.src = src;
	};
};
var myimg = createImg();
document.body.appendChild(myimg.img);
proxyImgLoading(myimg.img, imgurl);
			</pre>
			<pre>
//使用代理合并多次http请求
//假设页面有一堆type="checkbox"的input
var synchronousFile = function(id){
    console.log('开始同步文件，id为：' + id);  
};

var proxySynchronous = (function(){
    var cache = [];//缓存2s内的所有请求
    var timer;//控制请求的发起
    return function(id){
        cache.push(id);
        if(timer){
            return;
        }
        //每次用户勾选之后2s才发起一次请求
        timer = setTimeout(function(){
            synchronousFile(cache.join(','));
            clearTimeout( timer );
            timer = null;
            cache.length = 0;
        }, 2000);
    };
})();

var checkbox = document.getElementsByTagName('input');
for(var i = 0, c; c = checkbox[i++]; ){
    c.onclick = function(){
        if(this.checked === true){
            proxySynchronous(this.id);
        }  
    };
}
			</pre>
			<pre>
//高阶函数动态创建代理
var mult = function(){//计算乘积
    var a = 1;
    for(var i = 0, l = arguments.length; i < l; i++){
        a *= arguments[i];
    }
    return a;
};

var plus = function(){//计算加和
    var a = 0;
    for(var i = 0, l = arguments.length; i < l; i++){
        a += arguments[i];
    }
    return a;
};

var createProxyFactory = function(fn){
    var cache = {};
    return function(){
        var args = Array.prototype.join.call( arguments, ',' );
        if(args in cache){
            return cache[ args ];
        }  
        return cache[ args ] = fn.apply( this, arguments );
    };
};

var proxyMult = createProxyFactory(mult), proxyPlus = createProxyFactory(plus);

console.log(proxyMult(2,4,3,5,6));
console.log(proxyMult(2,4,3,5,6));
console.log(proxyPlus(2,4,3,5,6));
console.log(proxyPlus(2,4,3,5,6));
			</pre>
		</li>
		<li>
			<h3 id="c">3、单例模式</h3>
			<p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
			<p>惰性单例：指在需要的时候才创建对象实例，这种技术在实际开发中非常有用。</p>
			<p>js中的闭包让实现单例变得异常简单，单例模式简单易用，可以根据自己的使用场景创建各种变体，只要遵循只有一个实例，并提供全局访问的核心理念即可。</p>
			<pre>

//示例，一个简单的单例实现，缺点是使用者要时刻记住不要自己去new Singleton，开销是getInstance时每次都要进行判断
var Singleton = function(a){
	this.a = a;
	this.instance = null;
}
Singleton.getInstance = function(a){
	if(!this.instance){
		this.instance = new Singleton(a);
	}
	return this.instance;
}
			</pre>
			<pre>

//利用闭包动态创建命名空间
var MyApp = (function(){
	var MyApp = {};
	MyApp.namespace = function(name){
		var parts = name.split('.');
		var current = MyApp;
		for(var i in parts){
			if(!current[parts[i]]){
				current[parts[i]] = {};
			}
			current = current[parts[i]];
		}
	};
	return MyApp;
})();

MyApp.namespace('a.b');
MyApp.namespace('c.d.e');
			</pre>
			<pre>

//通用的惰性单例实现
var getSingle = function( fn ) {
	var result;
	return function () {
		return result || ( result = fn.apply(this, arguments) );
	};
};

var test = function(str){
	console.log(str);
	return '还是这个';
};

var singleTest = getSingle(test);//将函数包装成单例函数

console.log(singleTest('第一次调用'));//第一次调用 还是这个
console.log(singleTest('第二次调用'));//还是这个
console.log(singleTest('第三次调用'));//还是这个

//第二三次调用并不会输出，因为test函数只会执行一次
			</pre>
		</li>
		<li>
			<h3 id="d">4、迭代器模式</h3>
			<p>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
			<p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。迭代器的使用方式灵活多变，使用时要灵活变通。</p>
			<pre>
//实现自己的迭代器
//内部迭代器（自动迭代）
var each = function(arr, callback){
	for(var i = 0, len = arr.length; i < len; i++){
		callback.call(arr[i], i, arr[ i ]);
	}
};

each([1,2,3], function(index ,ele){
	console.log(ele);
});

//外部迭代器（手动控制）
var Iterator = function( obj ){
	var current = 0;

	var next = function(){
		current += 1;
	};
	var isDone = function(){
		return current >= obj.length;
	};
	var getCurrItem = function(){
		return obj[ current ];
	};

	return {
		next: next,
		isDone: isDone,
		getCurrItem: getCurrItem
	};
};

var iter = Iterator([2,4,6]);
while(!iter.isDone()){
	console.log(iter.getCurrItem());
	iter.next();
}
			</pre>
		</li>
		<li>
			<h3 id="e">5、发布-订阅模式</h3>
			<p>定义：又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
			<p>在异步编程中使用发布-订阅模式，我们就无需关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。发布订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式的调用另外一个对象的某个接口。</p>
			<p>实现步骤：①、指定好谁充当发布者；②、给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者；③、发布消息时，发布者遍历缓存列表，依次触发里面存放的订阅者回调函数。</p>
			<p>优点：时间上的解耦，对象之间的解耦</p>
			<p>缺点：创建订阅这本身要消耗一定的时间和内存，当订阅了一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。</p>
			<p>推模型：在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。</p>
			<p>拉模型：发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。</p>
			<p>发布-订阅模式在js中有很重要的作用，掌握并熟练使用发布-订阅模式对于开发者来说非常重要。</p>
			<pre>
//关于售楼处的发布订阅的例子
var salesOffices = {};//定义售楼处
salesOffices.clientList = [];//缓存列表
//添加监听
salesOffices.listen = function(key, fn){
	if( !this.clientList[ key ]){
		this.clientList[ key ] = [];
	}
	this.clientList[ key ].push( fn );
};

salesOffices.trigger = function(){
	//取出事件和对应的监听函数列表
	var key = Array.prototype.shift.call( arguments ),fns = this.clientList[ key ];
	if( !fns || fns.length === 0){//消息未被订阅过
		return false;
	}
	for( var i = 0, fn; fn = fns[ i++ ]; ){
		fn.apply( this, arguments );
	}
};

salesOffices.listen( 'squareMeter88', function(price){
	console.log('价格= ' + price);
});
salesOffices.listen( 'squareMeter110', function(price){
	console.log('价格= ' + price);
});
salesOffices.trigger( 'squareMeter88', 2000000 );//价格= 2000000
salesOffices.trigger( 'squareMeter110', 3000000 );//价格= 3000000
			</pre>
			<pre>
//自己实现的一个发布-订阅处理器
//这个处理器就相当于一个中介，订阅者不需要关心消息来自哪里，发布者不需要关心消息被推送给谁
//对于中介来说，可以在这个处理器中实现更复杂的逻辑，比如个性化的推送、根据发布者的等级推送给不同等级的订阅者等
var event = (function(){
	var Events = {};//缓存订阅的事件
	var Cache = {};//缓存发布的消息
	var listen, trigger, remove;

	listen = function (key){//支持多个回调
		if(typeof key !== 'string') return false;
		if(!Events[key]){
			Events[key] = [];
		}
		var _key = key;
		var fns = Events[key];//这个要放在上面，不然key就丢失了
		Array.prototype.shift.call(arguments);//去掉key
		//将所有的订阅回调注册在指定的订阅上
		for(var i = 0, fn; fn = arguments[i++]; ){
			if(typeof fn !== 'function') continue;
			fns.push(fn);
		}
		//添加订阅之后立即将已经缓存过的所有消息进行推送
		if(Cache[_key]){
			fns = Events[_key];
			var msgs = Cache[_key];
			for(i = 0; fn = fns[i++]; ){
				for(j = 0; j < msgs.length; j++){//触发时有消息
					fn.call(this, msgs[j]);
				}
			}
		}
		return true;
	};

	trigger = function (key){//支持多条消息
		if(typeof key !== 'string') return false;
		var _key = key;//记录key，因为下面会丢失掉key
		var i, j, fn;
		Array.prototype.shift.call(arguments);
		// 执行指定订阅上注册的所有回调
		if(Events[_key]){
			var fns = Events[_key];
			for(i = 0; fn = fns[i++]; ){
				if(arguments.length === 0) fn.call(this, '');//触发时未传消息
				for(j = 0; j < arguments.length; j++){//触发时有消息
					fn.call(this, arguments[j]);
				}
			}
		}
		//对消息的数据进行缓存，用于对订阅者进行立即的推送，在listen中
		if(!Cache[_key]){
			Cache[_key] = [];
		}
		for(i = 0; i < arguments.length; i++){
			Cache[_key].push(arguments[i]);
		}
	};

	remove = function (key){//支持移除多个回调
		if(typeof key !== 'string') return false;
		if(!Events[key]) return false;
		var fns = Events[key];
		var i, j, fn, _fn;
		Array.prototype.shift.call(arguments);//去掉参数中的key
		for(i = 0; fn = arguments[i++]; ){
			for(j = 0, _fn; _fn = fns[j++]; ){
				if(fn === _fn) fns.splice(j-1, 1);
			}
		}
	};

	return {
		listen:listen,
		trigger:trigger,
		remove:remove
	};
})();

// 测试监听
event.listen('a', a1, a2);//这两个回调要分别执行
event.trigger('a', 'a触发了', 'a又触发了');//这两个消息要分别都触发
event.trigger('a');//没有传入消息也要触发回调
// 测试发布
event.trigger('b', 'b发了第一个消息', 'b发了第二个消息');//先定制好两个消息
event.listen('b', b);//有此消息的订阅时会立即向订阅者进行推送
// 测试移除
event.remove('a', a1);//移除a1
event.trigger('a', 'a触发了', 'a又触发了');

function a1(m){
	console.log(m+'1');
}
function a2(m){
	console.log(m+'2');
}
function b(m){
	console.log(m);
}
/*运行结果*/
// a触发了1
// a又触发了1
// a触发了2
// a又触发了2
// 1
// 2
// b发了第一个消息
// b发了第二个消息
// a触发了2
// a又触发了2
			</pre>
			<pre>
//在上面的订阅器中，所有的消息都放在一个对象中，如果消息很多难免就会产生命名冲突
//下面的代码添加了在指定的命名空间下创建事件的功能，避免了不同的机构发布同一名称的消息产生冲突的问题
var Event = (function(){
	var global = this,
		Event,
		_default = 'default';

	Event = function(){
		var _listen,
			_trigger,
			_remove,
			_slice = Array.prototype.slice,
			_shift = Array.prototype.shift,
			_unshift = Array.prototype.unshift,
			namespaceCache = {},
			_create,
			find,
			each = function(ary, fn){
				var ret;
				for(var i = 0, l = ary.length; i < l; i++){
					var n = ary[i];
					ret = fn.call(n, i, n);
				}
				return ret;
			};

		_listen = function(key, fn, cache){
			if(!cache[key]){
				cache[key] = [];
			}
			cache[key].push(fn);
		};

		_remove = function(key, cache, fn){
			if(cache[key]){
				if(fn){
					for(var i = cache[key].length; i >= 0; i--){
						if(cache[key] === fn){
							cache[key].splice(i, 1);
						}
					}
				}else{
					cache[key] = [];
				}
			}
		};

		_trigger = function(){
			var cache = _shift.call(arguments),
				key = _shift.call(arguments),
				args = arguments,
				_self = this,
				ret,
				stack = cache[key];

			if(!stack || !stack.length){
				return;
			}

			return each(stack, function(){
				return this.apply(_self, args);
			});
		};

		_create = function(namespace){
			var namespace = namespace || _default;
			var cache = {},
				offlineStack = [],
				ret = {
					listen: function(key, fn, last){
						_listen(key, fn, cache);
						if(offlineStack === null){
							return;
						}
						if(last === 'last'){
							offlineStack.length && offlineStack.pop()();
						}else{
							each(offlineStack, function(){
								this();
							});
						}
						offlineStack = null;
					},
					one: function(key, fn, last){
						_remove(key, cache);
						this.listen(key, fn, last);
					},
					remove: function(key, fn){
						_remove(key, cache, fn);
					},
					trigger: function(){
						var fn,
							args,
							_self = this;

						_unshift.call(arguments, cache);
						args = arguments;
						fn = function(){
							return _trigger.apply(_self, args);
						};
						if(offlineStack){
							return offlineStack.push(fn);
						}
						return fn();
					}
				};
			return namespace ?
				(namespaceCache[namespace]?
				namespaceCache[namespace]:
				namespaceCache[namespace]=ret):
				ret;
		};

		return {
			create: _create,
			one: function(key, fn, last){
				var event = this.create( );
				event.one(key, fn, last);
			},
			remove: function(key, fn){
				var event = this.create( );
				event.remove(key, fn);
			},
			listen: function(key, fn, last){
				var event = this.create( );
				event.listen(key, fn, last);
			},
			trigger: function(){
				var event = this.create( );
				event.trigger.apply(this, arguments);
			}
		};
	}();

	return Event;
})();

// 先发布后订阅
Event.trigger('click', 1);
Event.listen('click', function(a){
	console.log(a);
});

//使用命名空间
Event.create('namespace1').listen('click', function(a){
	console.log(a);
});
Event.create('namespace1').trigger('click', 'namespace1');
Event.create('namespace2').trigger('click', 'namespace22');
Event.create('namespace2').trigger('click', 'namespace21');
Event.create('namespace2').trigger('click', 'namespace24');
Event.create('namespace2').listen('click', function(a){
	console.log(a);
}, 'last');
Event.create('namespace2').trigger('click', 'namespace23');
Event.create('namespace2').trigger('click', 'namespace25');
/*执行结果*/
//1
//namespace1
//namespace24
//namespace23
//namespace25
			</pre>
		</li>
		<li>
			<h3 id="f">6、命令模式</h3>
			<p>把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="g">7、模版方法模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="h">8、享元模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="i">9、职责链模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="j">10、中介者模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="k">11、装饰者模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="l">12、状态模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
		<li>
			<h3 id="m">13、组合模式</h3>
			<p>模式的定义以及自己的理解</p>
			<pre>function</pre>
			<p>代码解释</p>
		</li>
	</ul>
</div>

</body>
</html>