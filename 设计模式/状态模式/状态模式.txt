2016年6月11日 10:52:29

状态模式：状态模式是一种非同寻常的优秀模式，它也许是解决某些需求场景的最好方法，状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。

状态模式的关键是把事物的每种状态都封装成单独的类，跟此状态有关的行为都被封装在这个类的内部，同时还可以把状态的切换规则事先分布在状态类中，这样就有效的消除了原本存在的大量条件分支语句。

GoF定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
对上面这句话的解析：前一句的意思是将状态封装成独立的类，并将请求委托给当前的状态对象，当对象的内部状态改变时，会带来不同的行为变化。后一句是从客户的角度来看，我们使用的对象，在不同的状态下具有截然不同的行为，这个对象看起来是从不同的类中实例化而来的，实际上这是使用了委托的效果。

优点：
	状态模式定义了状态与行为之间的关系，并将它们封装在一个类里，通过增加新的状态类，很容易增加新的状态和转换。
	避免context无限膨胀，状态的切换的逻辑被分布在状态类中，也去掉了context中原本过多的条件分支。
	用对象代理字符串来记录当前状态，使得状态的切换更加一目了然。
	context中的请求动作和状态类中封装的行为可以非常独立的变化而互不影响。

缺点：会在系统中定义许多状态类，由于逻辑分散在状态类中，虽然避开了不受欢迎的条件分支语句，但也造成了逻辑分散的问题，我们无法在一个地方就看出整个状态机的逻辑。

策略模式和状态模式的相同点是都有一个上下文、一些策略或状态类，上下文把请求委托给这些类来执行。
区别是策略模式中的各个策略类之间是平等又平行的，它们之间没有任何联系，所以客户必须熟知这些策略类的作用，以便客户可以随时主动切换算法，而在状态模式中，状态和状态对应的行为是早已被封装好的，状态之间的切换也早被规定完成，‘改变行为’这件事情发生在状态模式内部，对客户来说，并不需要了解这些细节，这正是状态模式的作用所在。

表驱动的有限状态机，通过javascript Finite State Machine库实现。

通过状态模式重构代码之后，很多杂乱无章的代码会变得清晰，虽然状态模式一开始并不是非常容易理解，但我们有必要去好好掌握这种设计模式。